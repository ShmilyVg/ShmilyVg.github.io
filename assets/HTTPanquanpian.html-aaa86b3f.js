import{_ as s,p as a,q as e,Z as n}from"./framework-eb6cfbb5.js";const i={},t=n(`<h1 id="tls-是什么" tabindex="-1"><a class="header-anchor" href="#tls-是什么" aria-hidden="true">#</a> TLS 是什么</h1><h2 id="什么是安全" tabindex="-1"><a class="header-anchor" href="#什么是安全" aria-hidden="true">#</a> 什么是安全</h2><p>通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是：机密性、完整性，身份认证和不可否认。</p><p><strong>机密性</strong>：是指对数据的“保密”，只能由可信的人访问</p><p><strong>完整性</strong>：是指数据在传输过程中没有被窜改，不多也不少</p><p><strong>身份认证</strong>：是指确认对方的真实身份</p><p><strong>不可否认</strong>：也叫不可抵赖，意思是不能否认已经发生过的行为</p><p><strong>“https”，默认端口号 443</strong>，其他都完全沿用 HTTP，没有任何新的东西。</p><p><img src="https://static001.geekbang.org/resource/image/50/a3/50d57e18813e18270747806d5d73f0a3.png" alt=""></p><h2 id="ssl-tls" tabindex="-1"><a class="header-anchor" href="#ssl-tls" aria-hidden="true">#</a> SSL/TLS</h2><p>SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层）</p><p>SSL 发展到 v3 时在 1999 年改名为 TLS</p><h1 id="对称加密与非对称加密" tabindex="-1"><a class="header-anchor" href="#对称加密与非对称加密" aria-hidden="true">#</a> 对称加密与非对称加密</h1><h2 id="对称加密" tabindex="-1"><a class="header-anchor" href="#对称加密" aria-hidden="true">#</a> 对称加密</h2><p>AES（高级加密标准）密钥长度可以是 128、192 或 256。</p><p>ChaCha20 密钥长度固定为 256 位</p><h2 id="非对称加密-运算速度很慢" tabindex="-1"><a class="header-anchor" href="#非对称加密-运算速度很慢" aria-hidden="true">#</a> 非对称加密（运算速度很慢）</h2><p>RSA 它的安全性基于“<strong>整数分解</strong>”的数学难题，使用两个超大素数的乘积作为生成密钥的材料</p><p>ECC 基于“<strong>椭圆曲线离散对数</strong>”的数学难题，使用特定的曲线方程和基点生成公钥和私钥</p><h2 id="混合加密-tls" tabindex="-1"><a class="header-anchor" href="#混合加密-tls" aria-hidden="true">#</a> 混合加密（TLS）</h2><p>通信刚开始的时候使用非对称算法,解决密钥交换的问题。用随机数产生对称算法使用的“<strong>会话密钥</strong>”，再用公钥加密。(会话密钥很短,16/32 字节慢一点也无所谓)。对方拿到密文后用私钥解密，取出会话密钥。这样就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。</p><p><img src="https://static001.geekbang.org/resource/image/e4/85/e41f87110aeea3e548d58cc35a478e85.png" alt=""></p><h1 id="数字签名与证书" tabindex="-1"><a class="header-anchor" href="#数字签名与证书" aria-hidden="true">#</a> 数字签名与证书</h1><h2 id="摘要算法" tabindex="-1"><a class="header-anchor" href="#摘要算法" aria-hidden="true">#</a> 摘要算法</h2><p>可近似地理解成一种特殊的压缩算法，能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串</p><p>摘要算法对输入具有“单向性”和“雪崩效应”，输入的微小不同会导致输出的剧烈变化</p><p><img src="https://static001.geekbang.org/resource/image/28/d8/2865d2c77466efb7a480833bcb27f9d8.png" alt=""></p><p>常用的摘要算法：MD5、SHA-1</p><h2 id="完整性" tabindex="-1"><a class="header-anchor" href="#完整性" aria-hidden="true">#</a> 完整性</h2><p>摘要算法保证了“数字摘要”和原文是完全等价的。只要在原文后附上它的摘要，就能够保证数据的完整性。</p><p><img src="https://static001.geekbang.org/resource/image/c2/96/c2e10e9afa1393281b5633b1648f2696.png" alt=""></p><h1 id="tls1-2-的连接过程" tabindex="-1"><a class="header-anchor" href="#tls1-2-的连接过程" aria-hidden="true">#</a> TLS1.2 的连接过程</h1><h2 id="tls-协议由子协议组成" tabindex="-1"><a class="header-anchor" href="#tls-协议由子协议组成" aria-hidden="true">#</a> TLS 协议由子协议组成</h2><ul><li>记录协议：规定了 TLS 收发数据的基本单位：记录</li><li>报警协议：向对方发出警报信息</li><li>握手协议：TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。</li><li>变更密码规范协议：告诉对方，后续的数据都将使用加密保护</li></ul><h2 id="ecdhe-握手过程" tabindex="-1"><a class="header-anchor" href="#ecdhe-握手过程" aria-hidden="true">#</a> ECDHE 握手过程</h2><p><img src="https://static001.geekbang.org/resource/image/9c/1e/9caba6d4b527052bbe7168ed4013011e.png" alt=""></p><h2 id="rsa-握手过程" tabindex="-1"><a class="header-anchor" href="#rsa-握手过程" aria-hidden="true">#</a> RSA 握手过程</h2><p><img src="https://static001.geekbang.org/resource/image/cb/d2/cb9a89055eadb452b7835ba8db7c3ad2.png" alt=""></p><h1 id="tls1-3-新特性" tabindex="-1"><a class="header-anchor" href="#tls1-3-新特性" aria-hidden="true">#</a> TLS1.3 新特性</h1><ul><li>为了兼容 1.1、1.2 等“老”协议，TLS1.3 会“伪装”成 TLS1.2，新特性在“扩展”里实现；</li><li>1.1、1.2 在实践中发现了很多安全隐患，所以 TLS1.3 大幅度删减了加密算法，只保留了 ECDHE、AES、ChaCha20、SHA-2 等极少数算法，强化了安全；</li><li>TLS1.3 也简化了握手过程，完全握手只需要一个消息往返，提升了性能。</li></ul><h1 id="https-优化" tabindex="-1"><a class="header-anchor" href="#https-优化" aria-hidden="true">#</a> HTTPS 优化</h1><ul><li>可以有多种硬件和软件手段减少网络耗时和计算耗时，让 HTTPS 变得和 HTTP 一样快，最可行的是软件优化；</li><li>应当尽量使用 ECDHE 椭圆曲线密码套件，节约带宽和计算量，还能实现“False Start”；</li><li>服务器端应当开启“OCSP Stapling”功能，避免客户端访问 CA 去验证证书；</li><li>会话复用的效果类似 Cache，前提是客户端必须之前成功建立连接，后面就可以用“Session ID”“Session Ticket”等凭据跳过密钥交换、证书验证等步骤，直接开始加密通信。</li></ul><h1 id="迁移-https" tabindex="-1"><a class="header-anchor" href="#迁移-https" aria-hidden="true">#</a> 迁移 HTTPS</h1><h2 id="迁移的顾虑" tabindex="-1"><a class="header-anchor" href="#迁移的顾虑" aria-hidden="true">#</a> 迁移的顾虑</h2><ul><li>“慢”，是指惯性思维，拿以前的数据来评估 HTTPS 的性能，认为 HTTPS 会增加服务器的成本，增加客户端的时延，影响用户体验。</li><li>“贵”，主要是指证书申请和维护的成本太高，网站难以承担。</li><li>难”，是指 HTTPS 涉及的知识点太多、太复杂，有一定的技术门槛，不能很快上手。</li></ul><h2 id="从-http-切换到-https-流程" tabindex="-1"><a class="header-anchor" href="#从-http-切换到-https-流程" aria-hidden="true">#</a> 从 HTTP 切换到 HTTPS 流程</h2><p><strong>1.申请证书：Let’s Encrypt（免费，中小型公司适用）</strong></p><p>注意事项：</p><ul><li>申请证书时应当同时申请 RSA 和 ECDSA 两种证书，在 Nginx 里配置成双证书验证，这样服务器可以自动选择快速的椭圆曲线证书，同时也兼容只支持 RSA 的客户端。</li><li>申请 RSA 证书，私钥至少要 2048 位，摘要算法应该选用 SHA-2，如 SHA256、SHA384 等</li><li>出于安全的考虑，“Let’s Encrypt”证书的有效期很短，只有 90 天，时间一到就会过期失效，所以必须要定期更新（在 crontab 里加个每周或每月任务，发送更新请求）</li></ul><p><strong>2.配置 HTTPS</strong></p><p>配置 Web 服务器：nginx 上非常简单，只要在“listen”指令后面加上参数“ssl”，再配上刚才的证书文件就可以实现最基本的 HTTPS</p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">listen</span>                <span class="token number">443</span> ssl</span><span class="token punctuation">;</span>

<span class="token directive"><span class="token keyword">ssl_certificate</span>       xxx_rsa.crt</span><span class="token punctuation">;</span>  <span class="token comment">#rsa2048 cert</span>
<span class="token directive"><span class="token keyword">ssl_certificate_key</span>   xxx_rsa.key</span><span class="token punctuation">;</span>  <span class="token comment">#rsa2048 private key</span>

<span class="token directive"><span class="token keyword">ssl_certificate</span>       xxx_ecc.crt</span><span class="token punctuation">;</span>  <span class="token comment">#ecdsa cert</span>
<span class="token directive"><span class="token keyword">ssl_certificate_key</span>   xxx_ecc.key</span><span class="token punctuation">;</span>  <span class="token comment">#ecdsa private ke</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了提高 HTTPS 的安全系数和性能，可以强制 Nginx 只支持 TLS1.2 以上的协议，打开“Session Ticket”会话复用：</p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">ssl_protocols</span>               TLSv1.2 TLSv1.3</span><span class="token punctuation">;</span>

<span class="token directive"><span class="token keyword">ssl_session_timeout</span>         <span class="token number">5m</span></span><span class="token punctuation">;</span>
<span class="token directive"><span class="token keyword">ssl_session_tickets</span>         <span class="token boolean">on</span></span><span class="token punctuation">;</span>
<span class="token directive"><span class="token keyword">ssl_session_ticket_key</span>      ticket.key</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>密码套件的选择方面，以服务器的套件优先，可以避免恶意客户端故意选择较弱的套件、降低安全等级，密码套件向 TLS1.3“看齐”，只使用 ECDHE、AES 和 ChaCha20，支持“False Start”</p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">ssl_prefer_server_ciphers</span>   <span class="token boolean">on</span></span><span class="token punctuation">;</span>


<span class="token directive"><span class="token keyword">ssl_ciphers</span>   ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-CHACHA20-POLY1305:ECDHE+AES128:!MD5:!SHA1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果服务器上使用了 OpenSSL 的分支 BorringSSL，那么还可以使用一个特殊的“等价密码组”（Equal preference cipher groups）特性，它可以让服务器配置一组“等价”的密码套件，在这些套件里允许客户端优先选择，比如这么配置：</p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">ssl_ciphers</span>
[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>全部配置完成后，可以访问https://www.ssllabs.com/，测试网站的安全程度</p><p><strong>3.服务器名称指示</strong></p><p>在 HTTP 协议里，多个域名可以同时在一个 IP 地址上运行，这就是“虚拟主机”</p><p>在 HTTPS 里，因为请求头只有在 TLS 握手之后才能发送，在握手时就必须选择“虚拟主机”对应的证书，TLS 无法得知域名的信息，就只能用 IP 地址来区分</p><p>解决这个问题得用到 TLS 的“扩展”，给协议加个<strong>SNI</strong>（Server Name Indication）的“补充条款”。它的作用和 Host 字段差不多，客户端会在“Client Hello”时带上域名信息，这样服务器就可以根据名字而不是 IP 地址来选择证书</p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code>Extension: server_name (len=19)
    Server Name Indication extension
        Server Name Type: host_name (0)
        Server Name: www.chrono.com
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4.重定向跳转</strong></p><p>把之前不安全的 HTTP 网址用 301 或 302“重定向”到新的 HTTPS 网站，这在 Nginx 里也很容易做到，使用“return”或“rewrite”都可以。</p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">return</span> <span class="token number">301</span> https://<span class="token variable">$host</span><span class="token variable">$request_uri</span></span><span class="token punctuation">;</span>             <span class="token comment"># 永久重定向</span>
<span class="token directive"><span class="token keyword">rewrite</span> ^  https://<span class="token variable">$host</span><span class="token variable">$request_uri</span> permanent</span><span class="token punctuation">;</span>   <span class="token comment"># 永久重定向</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式有<strong>两个问题</strong>一个是重定向增加了网络成本，多出了一次请求；另一个是存在安全隐患，重定向的响应可能会被“中间人”窜改，实现“会话劫持”，跳转到恶意网站。</p><p>“<strong>HSTS</strong>”（HTTP 严格传输安全，HTTP Strict Transport Security）的技术可以消除这种安全隐患。HTTPS 服务器需要在发出的响应头里添加一个“<strong>Strict-Transport-Security</strong>”的字段，再设定一个有效期，例如：</p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">Strict-Transport-Security:</span> max-age=15768000</span><span class="token punctuation">;</span> includeSubDomains
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>有了“HSTS”的指示，以后浏览器再访问同样的域名的时候就会自动把 URI 里的“http”改成“https”，直接访问安全的 HTTPS 网站。这样“中间人”就失去了攻击的机会，而且对于客户端来说也免去了一次跳转，加快了连接速度。</p>`,71),r=[t];function c(l,p){return a(),e("div",null,r)}const o=s(i,[["render",c],["__file","HTTPanquanpian.html.vue"]]);export{o as default};
